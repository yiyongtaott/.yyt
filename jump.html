<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Loading...</title>
    <link rel="icon" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f50d.svg" type="image/svg+xml">
    <style>
        body {
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #msg { font-size: 14px; color: #888; }
    </style>
</head>
<body>
    <div class="loader"></div>
    <div id="msg">正在初始化安全隧道...</div>

<script>
// === 修复后的代码 ===
(function() {
    // 1. 重写网络请求方法
    const originalFetch = window.fetch;
    window.fetch = function(input, init = {}) {
        let url = input;
        if (typeof input !== 'string' && input.url) {
            url = input.url;
        }
        
        // 如果是 HTTP 请求，使用特殊配置
        if (url && url.startsWith('http://')) {
            const newInit = {
                ...init,
                mode: 'no-cors',
                cache: 'no-cache',
                referrerPolicy: 'no-referrer',
                credentials: 'omit'
            };
            
            console.log('Proxying HTTP request:', url);
            return originalFetch.call(this, url, newInit);
        }
        
        return originalFetch.call(this, input, init);
    };
    
    // 2. 重写 XHR
    const OriginalXHR = window.XMLHttpRequest;
    window.XMLHttpRequest = class extends OriginalXHR {
        open(method, url, async = true, user, password) {
            this._isHttpRequest = url && url.startsWith('http://');
            super.open(method, url, async, user, password);
            
            if (this._isHttpRequest) {
                // 设置请求头
                this.setRequestHeader('Accept', '*/*');
            }
        }
        
        send(body) {
            this.timeout = 15000;
            super.send(body);
        }
    };
})();

// 3. 执行 HTTP 请求
(async () => {
    const target = "http://9.3.0.1.9.1.0.0.0.7.4.0.1.0.0.2.ip6.arpa/?get_source=1";
    
    try {
        // 使用修改后的 fetch
        const response = await fetch(target);
        
        if (response.ok || response.type === 'opaque') {
            const text = await response.text();
            
            if (text && text.trim()) {
                // 创建 Blob URL（模拟本地文件）
                const blob = new Blob([text], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                // 方法1：直接在当前页面加载
                document.open();
                document.write(text);
                document.close();
                
                // 方法2：在新窗口打开（备用）
                // window.open(blobUrl, '_blank');
            } else {
                document.body.innerHTML = "获取到空内容";
            }
        } else {
            document.body.innerHTML = `请求失败: ${response.status}`;
        }
    } catch (error) {
        console.error('请求错误:', error);
        
        // 备用方案：使用 iframe 代理
        document.body.innerHTML = `
            <h3>正在使用备用方案加载...</h3>
            <iframe 
                src="https://yiyongtaott.github.io/.yyt/404.html?url=${encodeURIComponent(target)}"
                style="width:100%;height:100%;border:none;">
            </iframe>
        `;
    }
})();
</script>
</body>
</html>
